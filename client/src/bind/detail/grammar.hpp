//---------------------------------------------------------------------------////    This file is part of BIND library//    Copyright (C) 2011 Ilya Golovenko////---------------------------------------------------------------------------#ifndef _bind_detail_grammar_hpp#define _bind_detail_grammar_hpp#if defined(_MSC_VER) && (_MSC_VER >= 1200)# pragma once#endif  // defined(_MSC_VER) && (_MSC_VER >= 1200)#include <bind/enum.hpp>#include <bind/struct.hpp>#include <bind/context.hpp>// BOOST headers#include <boost/spirit/include/qi.hpp>#include <boost/spirit/include/phoenix.hpp>#include <boost/fusion/include/adapt_struct.hpp>using namespace bind;BOOST_FUSION_ADAPT_STRUCT(    enum_val,    (utf8::string, name)    (boost::int32_t, value)) BOOST_FUSION_ADAPT_STRUCT(    struct_val,    (value_attr, value_attr)    (value_type, value_type)    (utf8::string, type_name)    (utf8::string, value_name)    (utf8::string, json_name) )namespace bind{namespace detail{namespace qi = boost::spirit::qi;template <typename Iterator>struct grammar : qi::grammar<Iterator, context(), qi::space_type>{    grammar() : grammar::base_type(start_)    {        using qi::_1;        using qi::_val;        using qi::int_;        using qi::char_;        using qi::string;        using qi::attr;        using qi::no_case;        value_attrs_.add            ("requires", value_attr::required)            ("optional", value_attr::optional)            ("repeated", value_attr::repeated)            ;        values_types_.add            ("string", value_type::string)            ("int32", value_type::int32)            ("uint32", value_type::uint32)            ("int64", value_type::int64)            ("uint64", value_type::uint64)            ("bool", value_type::bool_)            ("double", value_type::double_)            //("enum", value_type::enum_)            //("struct", value_type::struct_)            ;        alpha_      =   no_case                        [                            char_('a', 'z')                        ]                    ;        digit_      =   char_('0', '9');        alnum_      =   alpha_                    |   digit_                    ;        token       =   alpha_                    |   char_('_')                    >> *(   alnum_                        |   char_('_')                        )                    ;        enum_val_   =   token_      // error on duplicates                    >>  '='                    >>  int_        // error on duplicates                    >>  ';'                    ;        enum_       =   "enum"                    >>  token_      // error on duplicates                    >>  '{'                    >> +enum_val_                    >>  '}'                    ;        type_       =   types_                    >>  attr(std::string())                    |   "enum"                    >>  attr(value_type::enum_)                    >>  token_                    |   "struct"                    >>  attr(value_type::struct_)                    >>  token_                    ;        json_       =   '"'                    >>  string                    >>  '"'                    ;        struct_val_ =   attrs_                    >>  type_                    >>  token_      // error on duplicates                    >>  '='                    >>  json_       // UTF-8 string, error on duplicates                    >>  ';'                    ;        struct_     =   "struct"                    >>  token_      // error on duplicates                    >>  '{'                    >> +struct_val_                    >>  '}'                    ;        namespace_  =   "namespace"                    >>  token_      // error on duplicate                    >>  '{'                 [push_namespace(_r1, _1)]   // context::push_namespace(utf8::string const& name)                    >> *content_                    >>  '}'                 [pop_namespace(_r1)]        // context::pop_namespace()                    ;        content_    =  *(   namespace_(_r1)                        |   struct_         [add_struct(_r1, _1)]       // context::add_struct(struct_ const& struct_)                        |   enum_           [add_enum(_r1, _1)]         // context::add_enum()enum_ const& enum_)                        )                    ;        start_      =  *content_(_val);    }    qi::symbols<char const, value_attr> attrs_;    qi::symbols<char const, value_type> types_;    qi::rule<Iterator, char()> alpha_;    qi::rule<Iterator, char()> digit_;    qi::rule<Iterator, char()> alnum_;    qi::rule<Iterator, std::string()> token_;    qi::rule<Iterator, enum_val(), qi::space_type> enum_val_;    qi::rule<Iterator, enum_(), qi::space_type> enum_;    qi::rule<Iterator, value_type(), qi::space_type> type_;    qi::rule<Iterator, utf8::string(), qi::space_type> json_;    qi::rule<Iterator, struct_val(), qi::space_type> struct_val_;    qi::rule<Iterator, struct_(), qi::space_type> struct_;    qi::rule<Iterator, void(context&), qi::space_type> namespace_;    qi::rule<Iterator, void(context&), qi::space_type> content_;    qi::rule<Iterator, context(), qi::space_type> start_; };                }   // namespace detail}   // namespace bind                #endif  // _bind_detail_grammar_hpp